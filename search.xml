<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>go并发</title>
      <link href="2021/06/04/goCoroutines/"/>
      <url>2021/06/04/goCoroutines/</url>
      
        <content type="html"><![CDATA[<h1 id="1-CSP并发理论"><a href="#1-CSP并发理论" class="headerlink" title="1.CSP并发理论"></a>1.CSP并发理论</h1><p>异步asyn 并行：多个任务并发执行</p><p>同步sync 串行：多个任务依次执行</p><p>阻塞block 某个并发任务由于拿不到资源没法干活，从而无所事事地干等</p><p>进程并发-线程并发-协程并发</p><p>进程是资源分配的最小单位，一个程序的执行单元，每一个main函数就相当于一个进程</p><p>线程是CPU调度的最小单位，一个程序可能要读数据库，可能在做计算操作，通过多线程将CPU执行时间片分摊，让本来是串行执行的任务，不需要等待可以并发执行，但是多线程需要频繁的切换cpu，所以对资源开销很大。线程并发是伪并发</p><p>协程的并发是逻辑上的</p><p>2.并发和并行</p><pre class="language-none"><code class="language-none">A. 多线程程序在一个核的cpu上运行，就是并发。B. 多线程程序在多个核的cpu上运行，就是并行。</code></pre><p>协程和线程</p><pre class="language-none"><code class="language-none">协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。线程：一个线程上可以跑多个协程，协程是轻量级的线程。</code></pre><p>​    并发主要由切换时间片来实现”同时”运行，并行则是直接利用多核实现多线程的运行，go可以设置使用核数，以发挥多核计算机的能力。</p><p>goroutine 奉行通过通信来共享内存，而不是共享内存来通信。</p><p><strong>异步回调</strong>：A线程唤起B线程，令其干活，通知给B一个回调函数，命令B在干完活以后，执行这个函数，这个回调函数会与A线程发生交互 A不必阻塞等待B执行的结果，AB两个线程可以并发执行</p><p><strong>共享内存</strong>：多个并发线程通过共享内存的方式交互数据</p><p>线程安全问题：AB共享的数据可能被C并发修改</p><p><strong>同步锁/资源锁</strong> 为了解决共享内存锁导致的线程安全问题，共享的内存地址在特定时间段被特定线程锁定 加锁期间 其他线程无法访问 带来低效率问题</p><p><strong>死锁</strong> A锁住B的资源 B锁住A要的资源 AB同时阻塞 </p><p><strong>线程池</strong></p><ul><li><p>背景：线程的开销大</p></li><li><p>内存：保存上下文数据</p></li><li><p>CPU：线程调度</p><p>为了避免无度创建线程（内存溢出），在一个池中创建一堆线程，循环利用这些线程，用完了以后重置并丢回池中</p></li><li><p>利弊</p><p>利：谜面五毒创建线程，降低了OOM风险。弊：用不用都占用了一块内存开销</p></li></ul><p>线程并发的弊端 线程内存，啥也不干就拿走1M栈空间  1024条线程就占用1G内存 线程切换占CPU 内存共享不安全 加了锁效率又低下 回调地狱导致并发难度高（因为主线程来回调 不是顺序执行 又乱又难懂）</p><p><strong>CSP模型</strong></p><p>可通信的序列化你进程</p><p>并发的进程间通过管道进行通信</p><p><strong>共享内存VS管道</strong></p><p><strong>内存共享</strong>：通过内存共享通信</p><p><strong>管道</strong>：通过通信共享内存</p><h1 id="多协程"><a href="#多协程" class="headerlink" title="多协程"></a>多协程</h1><p>goruntine ： go +coruntine </p><h2 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h2><p>1.出让协程资源</p><p>runtime.Gosched()</p><p>让出CPU时间片，重新等待调度</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"runtime"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">Hello</span><span class="token punctuation">(</span>no <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span> <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> i <span class="token operator">==</span><span class="token number">5</span><span class="token punctuation">&#123;</span><span class="token comment">//调低当前协程的优先级</span>runtime<span class="token punctuation">.</span><span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"协程%d:%d\n"</span><span class="token punctuation">,</span>no<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">&#123;</span><span class="token keyword">go</span> <span class="token function">Hello</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>2.查看和设置可用内核数</p><p>runtime.NumCPU)()</p><p>runtime.GOMAXPROCS()</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"runtime"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"当前可用的CPU核心数"</span><span class="token punctuation">,</span>runtime<span class="token punctuation">.</span><span class="token function">NumCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//将可用CPU逻辑核心数设置为4，并返回先前的配置</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>3.协程自杀</p><p>runtime.Goexit()</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"runtime"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span> <span class="token punctuation">;</span>i<span class="token operator">++</span>  <span class="token punctuation">&#123;</span><span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">5</span><span class="token punctuation">&#123;</span>runtime<span class="token punctuation">.</span><span class="token function">Goexit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"goroutine"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span> <span class="token punctuation">;</span>i<span class="token operator">++</span>  <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main "</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>如果Goexit杀死的是主协程，那么子协程就会不受牵制，</p><p>子协程被杀死，不会影响主协程或其他子协程运行</p><h1 id="channel管道"><a href="#channel管道" class="headerlink" title="channel管道"></a>channel管道</h1><p>管道提供了一种通信机制，一个goroutine可以向另一goroutine发送消息</p><p>channel本身还需关联一个类型，也就是说chaane可以发送数据的类型，如：</p><p>chan int  表示可以向这个channel中发送int类型的数据</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>ch := make(chan int)</p><h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><p>管道的读、写、遍历、只读、只写</p><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p>close(channel)</p><p>关闭了的管道不能写数据，但可以读数据，关闭且已读空的管道，再次读取时为管道类型零值</p><p>注意事项：</p><p>1.不能关闭一个未初始化（nil）的管道   painc： close of nil channel</p><p>2.不能向一个已经关闭的管道写数据 painc：send on closed channel</p><p>3.不能重复关闭一个管道 painc: close of closed channel</p><p>4.关闭channel会产生一个广播机制，向所有读取channel的goroutine都会收到消息</p><p>关闭管道，不在写入，通知所有的读取协程，（不在阻塞遍历）</p><h2 id="阻塞与调度"><a href="#阻塞与调度" class="headerlink" title="阻塞与调度"></a>阻塞与调度</h2><h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker拉取镜像失败</title>
      <link href="2021/06/03/imagePullReset/"/>
      <url>2021/06/03/imagePullReset/</url>
      
        <content type="html"><![CDATA[<p>使用docker拉取镜像报错</p><h1 id="问题现象："><a href="#问题现象：" class="headerlink" title="问题现象："></a>问题现象：</h1><p>使用docker拉取镜像报错</p><p><img src="/2021/06/03/imagePullReset/%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F%E6%8A%A5%E9%94%99.png" alt="拉取镜像报错" loading="lazy"><em>拉取镜像报错</em></p><p>retry 次数超出之后就会直接报错如下</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">read</span> tcp xx.xx.xx.xx:38762-<span class="token operator">></span>xx.xx.xx.xx:28086: read: connection reset by peer</code></pre><p>这个问题一般在公网环境下因为配置的docker官方镜像源，网络较慢或者国内的墙导致拉取不下来，配置阿里云或者其他的docker镜像加速地址即可解决，但此次我们是内网地址，所以并不是上述问题。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>发现有一层一直无法拉取</p><p>此时查看docker报错如下</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">level</span><span class="token operator">=</span>error <span class="token assign-left variable">msg</span><span class="token operator">=</span><span class="token string">"Download failed, retrying: read tcp xx.xx.xx.xx:38750->xxx.xxx.xxx.xxx:28086: read: connection reset by peer"</span></code></pre><p>尝试更换docker版本为18.09.5、20.20.6之后问题均依旧存在</p><p>尝试使用同机房同模板的初始机器直接安装docker仍旧存在问题</p><h2 id="使用tcpdump抓包分析网络情况"><a href="#使用tcpdump抓包分析网络情况" class="headerlink" title="使用tcpdump抓包分析网络情况"></a>使用tcpdump抓包分析网络情况</h2><pre class="language-bash" data-language="bash"><code class="language-bash">tcpdump -i ens192   <span class="token function">host</span> <span class="token operator">&lt;</span>镜像仓库地址<span class="token operator">></span> and port <span class="token operator">&lt;</span>镜像仓库端口<span class="token operator">></span> -s <span class="token number">0</span> -w test2.cap</code></pre><p>发现请求大部分都是正常的，这也对应访问镜像仓库的几个接口</p><p><img src="/2021/06/03/imagePullReset/%E6%8A%93%E5%8C%85%E6%88%AA%E5%9B%BE.png" alt="抓包" loading="lazy"></p><h3 id="1-鉴权"><a href="#1-鉴权" class="headerlink" title="1.鉴权"></a>1.鉴权</h3><p><img src="/2021/06/03/imagePullReset/%E6%8A%93%E5%8C%85%E6%88%AA%E5%9B%BE2.png" alt="鉴权" loading="lazy"></p><h3 id="2-使用token访问要拉取的镜像版本"><a href="#2-使用token访问要拉取的镜像版本" class="headerlink" title="2.使用token访问要拉取的镜像版本"></a>2.使用token访问要拉取的镜像版本</h3><p><img src="/2021/06/03/imagePullReset/%E6%8A%93%E5%8C%85%E6%88%AA%E5%9B%BE3.png" alt="拉取镜像" loading="lazy"></p><h3 id="3-拉取每一层镜像"><a href="#3-拉取每一层镜像" class="headerlink" title="3.拉取每一层镜像"></a>3.拉取每一层镜像</h3><p><img src="/2021/06/03/imagePullReset/%E6%8A%93%E5%8C%85%E6%88%AA%E5%9B%BE4.png" alt="拉取镜像" loading="lazy"></p><h3 id="4-下面就是数据包经过握手之后的分段传输"><a href="#4-下面就是数据包经过握手之后的分段传输" class="headerlink" title="4.下面就是数据包经过握手之后的分段传输"></a>4.下面就是数据包经过握手之后的分段传输</h3><p><img src="/2021/06/03/imagePullReset/%E6%8A%93%E5%8C%85%E6%88%AA%E5%9B%BE5.png" alt="拉取镜像" loading="lazy"></p><h3 id="5-下面问题就来了，有一层请求没有成功直接被reset了"><a href="#5-下面问题就来了，有一层请求没有成功直接被reset了" class="headerlink" title="5.下面问题就来了，有一层请求没有成功直接被reset了"></a>5.下面问题就来了，有一层请求没有成功直接被reset了</h3><p>TCP Previous segment not captured，这里就说明TCP连接被Reset了<br>原因可以参考<a href="https://blog.csdn.net/ixidof/article/details/8049667">https://blog.csdn.net/ixidof/article/details/8049667</a><br><img src="/2021/06/03/imagePullReset/%E6%8A%93%E5%8C%85%E6%88%AA%E5%9B%BE6.png" alt="拉取镜像" loading="lazy"></p><p>查看具体的请求header<br><img src="/2021/06/03/imagePullReset/%E6%8A%93%E5%8C%85%E6%88%AA%E5%9B%BE7.png" alt="拉取镜像" loading="lazy"></p><h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><p>可以发现正好对应我们上图拉镜像拉不下来的层911b8422b695<br>我们直接通过抓包的请求拼接URL访问这个请求<br>curl -H “Authorization: Bearer token”  <a href="http://xx.xx.xxx.xx:80xx/v2/cnpcrd/test/blobs/sha256:911b8422b695c8a6721bd5097f920515e35648254c5c7b1cc8aeeaca149b50b9">http://xx.xx.xxx.xx:80xx/v2/cnpcrd/test/blobs/sha256:911b8422b695c8a6721bd5097f920515e35648254c5c7b1cc8aeeaca149b50b9</a><br>报错如下<br>curl: (56) Recv failure: Connection reset by peer<br>这又和前面docker的报错对应上了<br>通过和甲方沟通反馈 确认为安全设备的IPS策略拦截了这个请求。</p><p>下面是安全部门反馈的信息<br><img src="/2021/06/03/imagePullReset/%E5%8F%8D%E9%A6%88%E6%88%AA%E5%9B%BE1.jpg" alt="反馈" loading="lazy"><br>使用dive分析这个拉取不下来的镜像，发现<br>我们拉取无法拉取的镜像为第二层，此层添加了一个redis账户，镜像使用了此层的/etc/passwd文件，所以IPS安全策略将此拦截了。<br><img src="/2021/06/03/imagePullReset/%E9%95%9C%E5%83%8F%E5%88%86%E6%9E%90.png" alt="镜像分析" loading="lazy"></p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>关闭掉了安全策略IPS</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种工具代理设置</title>
      <link href="2021/06/01/%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/"/>
      <url>2021/06/01/%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="yum代理"><a href="#yum代理" class="headerlink" title="yum代理"></a>yum代理</h1><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /etc/profile<span class="token builtin class-name">export</span> <span class="token assign-left variable">http_proxy</span><span class="token operator">=</span>http://127.0.0.1:1080<span class="token builtin class-name">export</span> <span class="token assign-left variable">https_proxy</span><span class="token operator">=</span>http://127.0.0.1:1080<span class="token builtin class-name">export</span> <span class="token assign-left variable">no_proxy</span><span class="token operator">=</span><span class="token number">192.168</span>.179.136,192.168.179.137.192.168.2.138,localhost,127.0.0.1</code></pre><h1 id="ansible配置代理-yum"><a href="#ansible配置代理-yum" class="headerlink" title="ansible配置代理(yum)"></a>ansible配置代理(yum)</h1><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /etc bashrc<span class="token builtin class-name">export</span> <span class="token assign-left variable">http_proxy</span><span class="token operator">=</span>http://127.0.0.1:1080<span class="token builtin class-name">export</span> <span class="token assign-left variable">https_proxy</span><span class="token operator">=</span>http://127.0.0.1:1080<span class="token builtin class-name">export</span> <span class="token assign-left variable">no_proxy</span><span class="token operator">=</span><span class="token number">192.168</span>.179.136,192.168.179.137.192.168.2.138,localhost,127.0.0.1</code></pre><h1 id="git配置代理"><a href="#git配置代理" class="headerlink" title="git配置代理"></a>git配置代理</h1><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global http.proxy http://127.0.0.1:1080<span class="token comment"># git clone https://...</span><span class="token function">git</span> config --global https.proxy http://127.0.0.1:1080<span class="token comment"># git clone git://...</span><span class="token function">git</span> config --global core.gitproxy http://127.0.0.1:1080取消代理<span class="token function">git</span> config --global --unset http.proxy</code></pre><h1 id="windows加代理"><a href="#windows加代理" class="headerlink" title="windows加代理"></a>windows加代理</h1><pre class="language-bash" data-language="bash"><code class="language-bash">windows加代理<span class="token builtin class-name">set</span> <span class="token assign-left variable">http_proxy</span><span class="token operator">=</span>http://127.0.0.1:1080<span class="token builtin class-name">set</span> <span class="token assign-left variable">https_proxy</span><span class="token operator">=</span>http://127.0.0.1:1080</code></pre><h1 id="docker代理"><a href="#docker代理" class="headerlink" title="docker代理"></a>docker代理</h1><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p /etc/systemd/system/docker.service.d<span class="token function">vi</span> /etc/systemd/system/docker.service.d/http-proxy.conf<span class="token punctuation">[</span>Service<span class="token punctuation">]</span><span class="token assign-left variable">Environment</span><span class="token operator">=</span><span class="token string">"HTTP_PROXY=http://127.0.0.1:1080"</span> <span class="token string">"HTTPS_PROXY=http://127.0.0.1:1080"</span> <span class="token string">"NO_PROXY=localhost,127.0.0.1"</span></code></pre><h1 id="npm代理"><a href="#npm代理" class="headerlink" title="npm代理"></a>npm代理</h1><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token builtin class-name">set</span> <span class="token assign-left variable">proxy</span><span class="token operator">=</span>http://10.22.98.21:8080<span class="token function">npm</span> config <span class="token builtin class-name">set</span> https-proxy<span class="token operator">=</span>http://10.22.98.21:8080取消代理<span class="token function">npm</span> config delete proxy<span class="token function">npm</span> config delete https-proxynpm配置镜像源<span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry http://registry.npm.taobao.org</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxy </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
